// Code generated - EDITING IS FUTILE. DO NOT EDIT.
//
// Generated by pipeline:
//     terraform
// Using jennies:
//     TerraformDataSourceJenny
//     ComposableLatestMajorsOrXJenny
//
// Run 'go generate ./' from repository root to regenerate.

package provider

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure that the imports are used to avoid compiler errors.
var _ attr.Value
var _ diag.Diagnostic

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ datasource.DataSource              = &PanelCanvasDataSource{}
	_ datasource.DataSourceWithConfigure = &PanelCanvasDataSource{}
)

func NewPanelCanvasDataSource() datasource.DataSource {
	return &PanelCanvasDataSource{}
}

// PanelCanvasDataSource defines the data source implementation.
type PanelCanvasDataSource struct{}

type PanelCanvasDataSourceModel_Datasource struct {
	Type types.String `tfsdk:"type"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelCanvasDataSourceModel_Datasource) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Datasource struct {
		Type *string `json:"type,omitempty"`
		Uid  *string `json:"uid,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueStringPointer()
	attr_uid := m.Uid.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Datasource{
		Type: attr_type,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Datasource) ApplyDefaults() PanelCanvasDataSourceModel_Datasource {

	return m
}

type PanelCanvasDataSourceModel_GridPos struct {
	H      types.Int64 `tfsdk:"h"`
	W      types.Int64 `tfsdk:"w"`
	X      types.Int64 `tfsdk:"x"`
	Y      types.Int64 `tfsdk:"y"`
	Static types.Bool  `tfsdk:"static"`
}

func (m PanelCanvasDataSourceModel_GridPos) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_GridPos struct {
		H      int64 `json:"h"`
		W      int64 `json:"w"`
		X      int64 `json:"x"`
		Y      int64 `json:"y"`
		Static *bool `json:"static,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_h := m.H.ValueInt64()
	attr_w := m.W.ValueInt64()
	attr_x := m.X.ValueInt64()
	attr_y := m.Y.ValueInt64()
	attr_static := m.Static.ValueBoolPointer()

	model := &jsonPanelCanvasDataSourceModel_GridPos{
		H:      attr_h,
		W:      attr_w,
		X:      attr_x,
		Y:      attr_y,
		Static: attr_static,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_GridPos) ApplyDefaults() PanelCanvasDataSourceModel_GridPos {
	if m.H.IsNull() {
		m.H = types.Int64Value(9)
	}
	if m.W.IsNull() {
		m.W = types.Int64Value(12)
	}
	if m.X.IsNull() {
		m.X = types.Int64Value(0)
	}
	if m.Y.IsNull() {
		m.Y = types.Int64Value(0)
	}
	return m
}

type PanelCanvasDataSourceModel_Links struct {
	Title       types.String `tfsdk:"title"`
	Type        types.String `tfsdk:"type"`
	Icon        types.String `tfsdk:"icon"`
	Tooltip     types.String `tfsdk:"tooltip"`
	Url         types.String `tfsdk:"url"`
	Tags        types.List   `tfsdk:"tags"`
	AsDropdown  types.Bool   `tfsdk:"as_dropdown"`
	TargetBlank types.Bool   `tfsdk:"target_blank"`
	IncludeVars types.Bool   `tfsdk:"include_vars"`
	KeepTime    types.Bool   `tfsdk:"keep_time"`
}

func (m PanelCanvasDataSourceModel_Links) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Links struct {
		Title       string   `json:"title"`
		Type        string   `json:"type"`
		Icon        string   `json:"icon"`
		Tooltip     string   `json:"tooltip"`
		Url         string   `json:"url"`
		Tags        []string `json:"tags,omitempty"`
		AsDropdown  bool     `json:"asDropdown"`
		TargetBlank bool     `json:"targetBlank"`
		IncludeVars bool     `json:"includeVars"`
		KeepTime    bool     `json:"keepTime"`
	}

	m = m.ApplyDefaults()
	attr_title := m.Title.ValueString()
	attr_type := m.Type.ValueString()
	attr_icon := m.Icon.ValueString()
	attr_tooltip := m.Tooltip.ValueString()
	attr_url := m.Url.ValueString()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_asdropdown := m.AsDropdown.ValueBool()
	attr_targetblank := m.TargetBlank.ValueBool()
	attr_includevars := m.IncludeVars.ValueBool()
	attr_keeptime := m.KeepTime.ValueBool()

	model := &jsonPanelCanvasDataSourceModel_Links{
		Title:       attr_title,
		Type:        attr_type,
		Icon:        attr_icon,
		Tooltip:     attr_tooltip,
		Url:         attr_url,
		Tags:        attr_tags,
		AsDropdown:  attr_asdropdown,
		TargetBlank: attr_targetblank,
		IncludeVars: attr_includevars,
		KeepTime:    attr_keeptime,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Links) ApplyDefaults() PanelCanvasDataSourceModel_Links {
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.AsDropdown.IsNull() {
		m.AsDropdown = types.BoolValue(false)
	}
	if m.TargetBlank.IsNull() {
		m.TargetBlank = types.BoolValue(false)
	}
	if m.IncludeVars.IsNull() {
		m.IncludeVars = types.BoolValue(false)
	}
	if m.KeepTime.IsNull() {
		m.KeepTime = types.BoolValue(false)
	}
	return m
}

type PanelCanvasDataSourceModel_Transformations_Filter struct {
}

func (m PanelCanvasDataSourceModel_Transformations_Filter) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Transformations_Filter struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelCanvasDataSourceModel_Transformations_Filter{}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Transformations_Filter) ApplyDefaults() PanelCanvasDataSourceModel_Transformations_Filter {

	return m
}

type PanelCanvasDataSourceModel_Transformations struct {
	Disabled types.Bool                                         `tfsdk:"disabled"`
	Filter   *PanelCanvasDataSourceModel_Transformations_Filter `tfsdk:"filter"`
}

func (m PanelCanvasDataSourceModel_Transformations) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Transformations struct {
		Disabled *bool       `json:"disabled,omitempty"`
		Filter   interface{} `json:"filter,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_disabled := m.Disabled.ValueBoolPointer()
	var attr_filter interface{}
	if m.Filter != nil {
		attr_filter = m.Filter
	}

	model := &jsonPanelCanvasDataSourceModel_Transformations{
		Disabled: attr_disabled,
		Filter:   attr_filter,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Transformations) ApplyDefaults() PanelCanvasDataSourceModel_Transformations {

	return m
}

type PanelCanvasDataSourceModel_LibraryPanel struct {
	Name types.String `tfsdk:"name"`
	Uid  types.String `tfsdk:"uid"`
}

func (m PanelCanvasDataSourceModel_LibraryPanel) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_LibraryPanel struct {
		Name string `json:"name"`
		Uid  string `json:"uid"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	attr_uid := m.Uid.ValueString()

	model := &jsonPanelCanvasDataSourceModel_LibraryPanel{
		Name: attr_name,
		Uid:  attr_uid,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_LibraryPanel) ApplyDefaults() PanelCanvasDataSourceModel_LibraryPanel {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Constraint struct {
	Horizontal types.String `tfsdk:"horizontal"`
	Vertical   types.String `tfsdk:"vertical"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Constraint) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Constraint struct {
		Horizontal *string `json:"horizontal,omitempty"`
		Vertical   *string `json:"vertical,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_horizontal := m.Horizontal.ValueStringPointer()
	attr_vertical := m.Vertical.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Constraint{
		Horizontal: attr_horizontal,
		Vertical:   attr_vertical,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Constraint) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Constraint {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Placement struct {
	Top    types.Float64 `tfsdk:"top"`
	Left   types.Float64 `tfsdk:"left"`
	Right  types.Float64 `tfsdk:"right"`
	Bottom types.Float64 `tfsdk:"bottom"`
	Width  types.Float64 `tfsdk:"width"`
	Height types.Float64 `tfsdk:"height"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Placement) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Placement struct {
		Top    *float64 `json:"top,omitempty"`
		Left   *float64 `json:"left,omitempty"`
		Right  *float64 `json:"right,omitempty"`
		Bottom *float64 `json:"bottom,omitempty"`
		Width  *float64 `json:"width,omitempty"`
		Height *float64 `json:"height,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_top := m.Top.ValueFloat64Pointer()
	attr_left := m.Left.ValueFloat64Pointer()
	attr_right := m.Right.ValueFloat64Pointer()
	attr_bottom := m.Bottom.ValueFloat64Pointer()
	attr_width := m.Width.ValueFloat64Pointer()
	attr_height := m.Height.ValueFloat64Pointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Placement{
		Top:    attr_top,
		Left:   attr_left,
		Right:  attr_right,
		Bottom: attr_bottom,
		Width:  attr_width,
		Height: attr_height,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Placement) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Placement {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Background_Color struct {
	Fixed types.String `tfsdk:"fixed"`
	Field types.String `tfsdk:"field"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background_Color struct {
		Fixed *string `json:"fixed,omitempty"`
		Field *string `json:"field,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_fixed := m.Fixed.ValueStringPointer()
	attr_field := m.Field.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background_Color{
		Fixed: attr_fixed,
		Field: attr_field,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background_Color) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Background_Color {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Background_Image struct {
	Mode  types.String `tfsdk:"mode"`
	Field types.String `tfsdk:"field"`
	Fixed types.String `tfsdk:"fixed"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background_Image) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background_Image struct {
		Mode  string  `json:"mode"`
		Field *string `json:"field,omitempty"`
		Fixed *string `json:"fixed,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_field := m.Field.ValueStringPointer()
	attr_fixed := m.Fixed.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background_Image{
		Mode:  attr_mode,
		Field: attr_field,
		Fixed: attr_fixed,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background_Image) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Background_Image {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Background struct {
	Color *PanelCanvasDataSourceModel_Options_Root_Elements_Background_Color `tfsdk:"color"`
	Image *PanelCanvasDataSourceModel_Options_Root_Elements_Background_Image `tfsdk:"image"`
	Size  types.String                                                       `tfsdk:"size"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background struct {
		Color interface{} `json:"color,omitempty"`
		Image interface{} `json:"image,omitempty"`
		Size  *string     `json:"size,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	var attr_image interface{}
	if m.Image != nil {
		attr_image = m.Image
	}
	attr_size := m.Size.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Background{
		Color: attr_color,
		Image: attr_image,
		Size:  attr_size,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Background) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Background {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Border_Color struct {
	Fixed types.String `tfsdk:"fixed"`
	Field types.String `tfsdk:"field"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Border_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Border_Color struct {
		Fixed *string `json:"fixed,omitempty"`
		Field *string `json:"field,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_fixed := m.Fixed.ValueStringPointer()
	attr_field := m.Field.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Border_Color{
		Fixed: attr_fixed,
		Field: attr_field,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Border_Color) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Border_Color {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Border struct {
	Color *PanelCanvasDataSourceModel_Options_Root_Elements_Border_Color `tfsdk:"color"`
	Width types.Float64                                                  `tfsdk:"width"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Border) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Border struct {
		Color interface{} `json:"color,omitempty"`
		Width *float64    `json:"width,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	attr_width := m.Width.ValueFloat64Pointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Border{
		Color: attr_color,
		Width: attr_width,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Border) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Border {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source struct {
	X types.Float64 `tfsdk:"x"`
	Y types.Float64 `tfsdk:"y"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source struct {
		X float64 `json:"x"`
		Y float64 `json:"y"`
	}

	m = m.ApplyDefaults()
	attr_x := m.X.ValueFloat64()
	attr_y := m.Y.ValueFloat64()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source{
		X: attr_x,
		Y: attr_y,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target struct {
	X types.Float64 `tfsdk:"x"`
	Y types.Float64 `tfsdk:"y"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target struct {
		X float64 `json:"x"`
		Y float64 `json:"y"`
	}

	m = m.ApplyDefaults()
	attr_x := m.X.ValueFloat64()
	attr_y := m.Y.ValueFloat64()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target{
		X: attr_x,
		Y: attr_y,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color struct {
	Fixed types.String `tfsdk:"fixed"`
	Field types.String `tfsdk:"field"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color struct {
		Fixed *string `json:"fixed,omitempty"`
		Field *string `json:"field,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_fixed := m.Fixed.ValueStringPointer()
	attr_field := m.Field.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color{
		Fixed: attr_fixed,
		Field: attr_field,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size struct {
	Min   types.Float64 `tfsdk:"min"`
	Max   types.Float64 `tfsdk:"max"`
	Fixed types.Float64 `tfsdk:"fixed"`
	Field types.String  `tfsdk:"field"`
	Mode  types.String  `tfsdk:"mode"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size struct {
		Min   float64  `json:"min"`
		Max   float64  `json:"max"`
		Fixed *float64 `json:"fixed,omitempty"`
		Field *string  `json:"field,omitempty"`
		Mode  *string  `json:"mode,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_min := m.Min.ValueFloat64()
	attr_max := m.Max.ValueFloat64()
	attr_fixed := m.Fixed.ValueFloat64Pointer()
	attr_field := m.Field.ValueStringPointer()
	attr_mode := m.Mode.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size{
		Min:   attr_min,
		Max:   attr_max,
		Fixed: attr_fixed,
		Field: attr_field,
		Mode:  attr_mode,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements_Connections struct {
	Source     *PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Source `tfsdk:"source"`
	Target     *PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Target `tfsdk:"target"`
	TargetName types.String                                                         `tfsdk:"target_name"`
	Path       types.String                                                         `tfsdk:"path"`
	Color      *PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Color  `tfsdk:"color"`
	Size       *PanelCanvasDataSourceModel_Options_Root_Elements_Connections_Size   `tfsdk:"size"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections struct {
		Source     interface{} `json:"source,omitempty"`
		Target     interface{} `json:"target,omitempty"`
		TargetName *string     `json:"targetName,omitempty"`
		Path       string      `json:"path"`
		Color      interface{} `json:"color,omitempty"`
		Size       interface{} `json:"size,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_source interface{}
	if m.Source != nil {
		attr_source = m.Source
	}
	var attr_target interface{}
	if m.Target != nil {
		attr_target = m.Target
	}
	attr_targetname := m.TargetName.ValueStringPointer()
	attr_path := m.Path.ValueString()
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	var attr_size interface{}
	if m.Size != nil {
		attr_size = m.Size
	}

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements_Connections{
		Source:     attr_source,
		Target:     attr_target,
		TargetName: attr_targetname,
		Path:       attr_path,
		Color:      attr_color,
		Size:       attr_size,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements_Connections) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements_Connections {

	return m
}

type PanelCanvasDataSourceModel_Options_Root_Elements struct {
	Name        types.String                                                   `tfsdk:"name"`
	Type        types.String                                                   `tfsdk:"type"`
	Constraint  *PanelCanvasDataSourceModel_Options_Root_Elements_Constraint   `tfsdk:"constraint"`
	Placement   *PanelCanvasDataSourceModel_Options_Root_Elements_Placement    `tfsdk:"placement"`
	Background  *PanelCanvasDataSourceModel_Options_Root_Elements_Background   `tfsdk:"background"`
	Border      *PanelCanvasDataSourceModel_Options_Root_Elements_Border       `tfsdk:"border"`
	Connections []PanelCanvasDataSourceModel_Options_Root_Elements_Connections `tfsdk:"connections"`
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root_Elements struct {
		Name        string        `json:"name"`
		Type        string        `json:"type"`
		Constraint  interface{}   `json:"constraint,omitempty"`
		Placement   interface{}   `json:"placement,omitempty"`
		Background  interface{}   `json:"background,omitempty"`
		Border      interface{}   `json:"border,omitempty"`
		Connections []interface{} `json:"connections,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	attr_type := m.Type.ValueString()
	var attr_constraint interface{}
	if m.Constraint != nil {
		attr_constraint = m.Constraint
	}
	var attr_placement interface{}
	if m.Placement != nil {
		attr_placement = m.Placement
	}
	var attr_background interface{}
	if m.Background != nil {
		attr_background = m.Background
	}
	var attr_border interface{}
	if m.Border != nil {
		attr_border = m.Border
	}
	attr_connections := []interface{}{}
	for _, v := range m.Connections {
		attr_connections = append(attr_connections, v)
	}

	model := &jsonPanelCanvasDataSourceModel_Options_Root_Elements{
		Name:        attr_name,
		Type:        attr_type,
		Constraint:  attr_constraint,
		Placement:   attr_placement,
		Background:  attr_background,
		Border:      attr_border,
		Connections: attr_connections,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root_Elements) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root_Elements {

	return m
}

type PanelCanvasDataSourceModel_Options_Root struct {
	Name     types.String                                       `tfsdk:"name"`
	Type     types.String                                       `tfsdk:"type"`
	Elements []PanelCanvasDataSourceModel_Options_Root_Elements `tfsdk:"elements"`
}

func (m PanelCanvasDataSourceModel_Options_Root) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options_Root struct {
		Name     string        `json:"name"`
		Type     string        `json:"type"`
		Elements []interface{} `json:"elements,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_name := m.Name.ValueString()
	attr_type := m.Type.ValueString()
	attr_elements := []interface{}{}
	for _, v := range m.Elements {
		attr_elements = append(attr_elements, v)
	}

	model := &jsonPanelCanvasDataSourceModel_Options_Root{
		Name:     attr_name,
		Type:     attr_type,
		Elements: attr_elements,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options_Root) ApplyDefaults() PanelCanvasDataSourceModel_Options_Root {

	return m
}

type PanelCanvasDataSourceModel_Options struct {
	InlineEditing     types.Bool                               `tfsdk:"inline_editing"`
	ShowAdvancedTypes types.Bool                               `tfsdk:"show_advanced_types"`
	Root              *PanelCanvasDataSourceModel_Options_Root `tfsdk:"root"`
}

func (m PanelCanvasDataSourceModel_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_Options struct {
		InlineEditing     bool        `json:"inlineEditing"`
		ShowAdvancedTypes bool        `json:"showAdvancedTypes"`
		Root              interface{} `json:"root,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_inlineediting := m.InlineEditing.ValueBool()
	attr_showadvancedtypes := m.ShowAdvancedTypes.ValueBool()
	var attr_root interface{}
	if m.Root != nil {
		attr_root = m.Root
	}

	model := &jsonPanelCanvasDataSourceModel_Options{
		InlineEditing:     attr_inlineediting,
		ShowAdvancedTypes: attr_showadvancedtypes,
		Root:              attr_root,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_Options) ApplyDefaults() PanelCanvasDataSourceModel_Options {
	if m.InlineEditing.IsNull() {
		m.InlineEditing = types.BoolValue(true)
	}
	if m.ShowAdvancedTypes.IsNull() {
		m.ShowAdvancedTypes = types.BoolValue(true)
	}
	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options struct {
	Text  types.String `tfsdk:"text"`
	Color types.String `tfsdk:"color"`
	Icon  types.String `tfsdk:"icon"`
	Index types.Int64  `tfsdk:"index"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options struct {
		Text  *string `json:"text,omitempty"`
		Color *string `json:"color,omitempty"`
		Icon  *string `json:"icon,omitempty"`
		Index *int64  `json:"index,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_text := m.Text.ValueStringPointer()
	attr_color := m.Color.ValueStringPointer()
	attr_icon := m.Icon.ValueStringPointer()
	attr_index := m.Index.ValueInt64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options{
		Text:  attr_text,
		Color: attr_color,
		Icon:  attr_icon,
		Index: attr_index,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap struct {
	Type    types.String                                                                          `tfsdk:"type"`
	Options *map[string]PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap_Options `tfsdk:"options"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap struct {
		Type    string      `json:"type"`
		Options interface{} `json:"options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap{
		Type:    attr_type,
		Options: attr_options,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result struct {
	Text  types.String `tfsdk:"text"`
	Color types.String `tfsdk:"color"`
	Icon  types.String `tfsdk:"icon"`
	Index types.Int64  `tfsdk:"index"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result struct {
		Text  *string `json:"text,omitempty"`
		Color *string `json:"color,omitempty"`
		Icon  *string `json:"icon,omitempty"`
		Index *int64  `json:"index,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_text := m.Text.ValueStringPointer()
	attr_color := m.Color.ValueStringPointer()
	attr_icon := m.Icon.ValueStringPointer()
	attr_index := m.Index.ValueInt64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result{
		Text:  attr_text,
		Color: attr_color,
		Icon:  attr_icon,
		Index: attr_index,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options struct {
	From   types.String                                                                      `tfsdk:"from"`
	To     types.String                                                                      `tfsdk:"to"`
	Result *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options_Result `tfsdk:"result"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options) GetAttrFrom() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseFloat(m.From.ValueString(), 64)
	if err == nil {
		return attr
	}

	if err == nil {
		return attr
	}

	return m.From.ValueString()
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options) GetAttrTo() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseFloat(m.To.ValueString(), 64)
	if err == nil {
		return attr
	}

	if err == nil {
		return attr
	}

	return m.To.ValueString()
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options struct {
		From   interface{} `json:"from"`
		To     interface{} `json:"to"`
		Result interface{} `json:"result,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_from := m.GetAttrFrom()
	attr_to := m.GetAttrTo()
	var attr_result interface{}
	if m.Result != nil {
		attr_result = m.Result
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options{
		From:   attr_from,
		To:     attr_to,
		Result: attr_result,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap struct {
	Type    types.String                                                               `tfsdk:"type"`
	Options *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap_Options `tfsdk:"options"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap struct {
		Type    string      `json:"type"`
		Options interface{} `json:"options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap{
		Type:    attr_type,
		Options: attr_options,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result struct {
	Text  types.String `tfsdk:"text"`
	Color types.String `tfsdk:"color"`
	Icon  types.String `tfsdk:"icon"`
	Index types.Int64  `tfsdk:"index"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result struct {
		Text  *string `json:"text,omitempty"`
		Color *string `json:"color,omitempty"`
		Icon  *string `json:"icon,omitempty"`
		Index *int64  `json:"index,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_text := m.Text.ValueStringPointer()
	attr_color := m.Color.ValueStringPointer()
	attr_icon := m.Icon.ValueStringPointer()
	attr_index := m.Index.ValueInt64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result{
		Text:  attr_text,
		Color: attr_color,
		Icon:  attr_icon,
		Index: attr_index,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options struct {
	Pattern types.String                                                                      `tfsdk:"pattern"`
	Result  *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options_Result `tfsdk:"result"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options struct {
		Pattern string      `json:"pattern"`
		Result  interface{} `json:"result,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_pattern := m.Pattern.ValueString()
	var attr_result interface{}
	if m.Result != nil {
		attr_result = m.Result
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options{
		Pattern: attr_pattern,
		Result:  attr_result,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap struct {
	Type    types.String                                                               `tfsdk:"type"`
	Options *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap_Options `tfsdk:"options"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap struct {
		Type    string      `json:"type"`
		Options interface{} `json:"options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap{
		Type:    attr_type,
		Options: attr_options,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result struct {
	Text  types.String `tfsdk:"text"`
	Color types.String `tfsdk:"color"`
	Icon  types.String `tfsdk:"icon"`
	Index types.Int64  `tfsdk:"index"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result struct {
		Text  *string `json:"text,omitempty"`
		Color *string `json:"color,omitempty"`
		Icon  *string `json:"icon,omitempty"`
		Index *int64  `json:"index,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_text := m.Text.ValueStringPointer()
	attr_color := m.Color.ValueStringPointer()
	attr_icon := m.Icon.ValueStringPointer()
	attr_index := m.Index.ValueInt64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result{
		Text:  attr_text,
		Color: attr_color,
		Icon:  attr_icon,
		Index: attr_index,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options struct {
	Match  types.String                                                                             `tfsdk:"match"`
	Result *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options_Result `tfsdk:"result"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options struct {
		Match  string      `json:"match"`
		Result interface{} `json:"result,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_match := m.Match.ValueString()
	var attr_result interface{}
	if m.Result != nil {
		attr_result = m.Result
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options{
		Match:  attr_match,
		Result: attr_result,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap struct {
	Type    types.String                                                                      `tfsdk:"type"`
	Options *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap_Options `tfsdk:"options"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap struct {
		Type    string      `json:"type"`
		Options interface{} `json:"options,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap{
		Type:    attr_type,
		Options: attr_options,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings struct {
	ValueMap        *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_ValueMap        `tfsdk:"value_map"`
	RangeMap        *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RangeMap        `tfsdk:"range_map"`
	RegexMap        *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_RegexMap        `tfsdk:"regex_map"`
	SpecialValueMap *PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings_SpecialValueMap `tfsdk:"special_value_map"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings) MarshalJSON() ([]byte, error) {
	var json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings interface{}
	m = m.ApplyDefaults()
	if m.ValueMap != nil {
		json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings = m.ValueMap
	}
	if m.RangeMap != nil {
		json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings = m.RangeMap
	}
	if m.RegexMap != nil {
		json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings = m.RegexMap
	}
	if m.SpecialValueMap != nil {
		json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings = m.SpecialValueMap
	}

	return json.Marshal(json_PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
	Value types.String `tfsdk:"value"`
	Color types.String `tfsdk:"color"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) GetAttrValue() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseFloat(m.Value.ValueString(), 64)
	if err == nil {
		return attr
	}

	if err == nil {
		return attr
	}

	return m.Value.ValueString()
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps struct {
		Value interface{} `json:"value"`
		Color string      `json:"color"`
	}

	m = m.ApplyDefaults()
	attr_value := m.GetAttrValue()
	attr_color := m.Color.ValueString()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps{
		Value: attr_value,
		Color: attr_color,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds struct {
	Mode  types.String                                                       `tfsdk:"mode"`
	Steps []PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds_Steps `tfsdk:"steps"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds struct {
		Mode  string        `json:"mode"`
		Steps []interface{} `json:"steps,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_steps := []interface{}{}
	for _, v := range m.Steps {
		attr_steps = append(attr_steps, v)
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds{
		Mode:  attr_mode,
		Steps: attr_steps,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Color struct {
	Mode       types.String `tfsdk:"mode"`
	FixedColor types.String `tfsdk:"fixed_color"`
	SeriesBy   types.String `tfsdk:"series_by"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Color) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Color struct {
		Mode       string  `json:"mode"`
		FixedColor *string `json:"fixedColor,omitempty"`
		SeriesBy   *string `json:"seriesBy,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()
	attr_fixedcolor := m.FixedColor.ValueStringPointer()
	attr_seriesby := m.SeriesBy.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Color{
		Mode:       attr_mode,
		FixedColor: attr_fixedcolor,
		SeriesBy:   attr_seriesby,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Color) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Color {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle struct {
	Mode types.String `tfsdk:"mode"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle struct {
		Mode string `json:"mode"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueString()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle{
		Mode: attr_mode,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle struct {
	Fill types.String `tfsdk:"fill"`
	Dash types.List   `tfsdk:"dash"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle struct {
		Fill *string   `json:"fill,omitempty"`
		Dash []float64 `json:"dash,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_fill := m.Fill.ValueStringPointer()
	attr_dash := []float64{}
	for _, v := range m.Dash.Elements() {
		attr_dash = append(attr_dash, v.(types.Float64).ValueFloat64())
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle{
		Fill: attr_fill,
		Dash: attr_dash,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle {
	if len(m.Dash.Elements()) == 0 {
		m.Dash, _ = types.ListValue(types.Float64Type, []attr.Value{})
	}
	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution struct {
	Type            types.String  `tfsdk:"type"`
	Log             types.Float64 `tfsdk:"log"`
	LinearThreshold types.Float64 `tfsdk:"linear_threshold"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution struct {
		Type            string   `json:"type"`
		Log             *float64 `json:"log,omitempty"`
		LinearThreshold *float64 `json:"linearThreshold,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_log := m.Log.ValueFloat64Pointer()
	attr_linearthreshold := m.LinearThreshold.ValueFloat64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution{
		Type:            attr_type,
		Log:             attr_log,
		LinearThreshold: attr_linearthreshold,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking struct {
	Mode  types.String `tfsdk:"mode"`
	Group types.String `tfsdk:"group"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking struct {
		Mode  *string `json:"mode,omitempty"`
		Group *string `json:"group,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_mode := m.Mode.ValueStringPointer()
	attr_group := m.Group.ValueStringPointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking{
		Mode:  attr_mode,
		Group: attr_group,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom struct {
	Tooltip types.Bool `tfsdk:"tooltip"`
	Legend  types.Bool `tfsdk:"legend"`
	Viz     types.Bool `tfsdk:"viz"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom struct {
		Tooltip bool `json:"tooltip"`
		Legend  bool `json:"legend"`
		Viz     bool `json:"viz"`
	}

	m = m.ApplyDefaults()
	attr_tooltip := m.Tooltip.ValueBool()
	attr_legend := m.Legend.ValueBool()
	attr_viz := m.Viz.ValueBool()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom{
		Tooltip: attr_tooltip,
		Legend:  attr_legend,
		Viz:     attr_viz,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom struct {
	DrawStyle         types.String                                                              `tfsdk:"draw_style"`
	GradientMode      types.String                                                              `tfsdk:"gradient_mode"`
	ThresholdsStyle   *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ThresholdsStyle   `tfsdk:"thresholds_style"`
	LineColor         types.String                                                              `tfsdk:"line_color"`
	LineWidth         types.Float64                                                             `tfsdk:"line_width"`
	LineInterpolation types.String                                                              `tfsdk:"line_interpolation"`
	LineStyle         *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_LineStyle         `tfsdk:"line_style"`
	FillColor         types.String                                                              `tfsdk:"fill_color"`
	FillOpacity       types.Float64                                                             `tfsdk:"fill_opacity"`
	ShowPoints        types.String                                                              `tfsdk:"show_points"`
	PointSize         types.Float64                                                             `tfsdk:"point_size"`
	PointColor        types.String                                                              `tfsdk:"point_color"`
	AxisPlacement     types.String                                                              `tfsdk:"axis_placement"`
	AxisColorMode     types.String                                                              `tfsdk:"axis_color_mode"`
	AxisLabel         types.String                                                              `tfsdk:"axis_label"`
	AxisWidth         types.Float64                                                             `tfsdk:"axis_width"`
	AxisSoftMin       types.Float64                                                             `tfsdk:"axis_soft_min"`
	AxisSoftMax       types.Float64                                                             `tfsdk:"axis_soft_max"`
	AxisGridShow      types.Bool                                                                `tfsdk:"axis_grid_show"`
	ScaleDistribution *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_ScaleDistribution `tfsdk:"scale_distribution"`
	BarAlignment      types.Int64                                                               `tfsdk:"bar_alignment"`
	BarWidthFactor    types.Float64                                                             `tfsdk:"bar_width_factor"`
	Stacking          *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_Stacking          `tfsdk:"stacking"`
	HideFrom          *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom_HideFrom          `tfsdk:"hide_from"`
	Transform         types.String                                                              `tfsdk:"transform"`
	SpanNulls         types.String                                                              `tfsdk:"span_nulls"`
	FillBelowTo       types.String                                                              `tfsdk:"fill_below_to"`
	PointSymbol       types.String                                                              `tfsdk:"point_symbol"`
	AxisCenteredZero  types.Bool                                                                `tfsdk:"axis_centered_zero"`
	BarMaxWidth       types.Float64                                                             `tfsdk:"bar_max_width"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom) GetAttrSpanNulls() interface{} {
	var attr interface{}
	var err error

	attr, err = strconv.ParseBool(m.SpanNulls.ValueString())
	if err == nil {
		return attr
	}
	attr, err = strconv.ParseFloat(m.SpanNulls.ValueString(), 64)
	if err == nil {
		return attr
	}

	return m.SpanNulls.ValueString()
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom struct {
		DrawStyle         *string     `json:"drawStyle,omitempty"`
		GradientMode      *string     `json:"gradientMode,omitempty"`
		ThresholdsStyle   interface{} `json:"thresholdsStyle,omitempty"`
		LineColor         *string     `json:"lineColor,omitempty"`
		LineWidth         *float64    `json:"lineWidth,omitempty"`
		LineInterpolation *string     `json:"lineInterpolation,omitempty"`
		LineStyle         interface{} `json:"lineStyle,omitempty"`
		FillColor         *string     `json:"fillColor,omitempty"`
		FillOpacity       *float64    `json:"fillOpacity,omitempty"`
		ShowPoints        *string     `json:"showPoints,omitempty"`
		PointSize         *float64    `json:"pointSize,omitempty"`
		PointColor        *string     `json:"pointColor,omitempty"`
		AxisPlacement     *string     `json:"axisPlacement,omitempty"`
		AxisColorMode     *string     `json:"axisColorMode,omitempty"`
		AxisLabel         *string     `json:"axisLabel,omitempty"`
		AxisWidth         *float64    `json:"axisWidth,omitempty"`
		AxisSoftMin       *float64    `json:"axisSoftMin,omitempty"`
		AxisSoftMax       *float64    `json:"axisSoftMax,omitempty"`
		AxisGridShow      *bool       `json:"axisGridShow,omitempty"`
		ScaleDistribution interface{} `json:"scaleDistribution,omitempty"`
		BarAlignment      *int64      `json:"barAlignment,omitempty"`
		BarWidthFactor    *float64    `json:"barWidthFactor,omitempty"`
		Stacking          interface{} `json:"stacking,omitempty"`
		HideFrom          interface{} `json:"hideFrom,omitempty"`
		Transform         *string     `json:"transform,omitempty"`
		SpanNulls         interface{} `json:"spanNulls,omitempty"`
		FillBelowTo       *string     `json:"fillBelowTo,omitempty"`
		PointSymbol       *string     `json:"pointSymbol,omitempty"`
		AxisCenteredZero  *bool       `json:"axisCenteredZero,omitempty"`
		BarMaxWidth       *float64    `json:"barMaxWidth,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_drawstyle := m.DrawStyle.ValueStringPointer()
	attr_gradientmode := m.GradientMode.ValueStringPointer()
	var attr_thresholdsstyle interface{}
	if m.ThresholdsStyle != nil {
		attr_thresholdsstyle = m.ThresholdsStyle
	}
	attr_linecolor := m.LineColor.ValueStringPointer()
	attr_linewidth := m.LineWidth.ValueFloat64Pointer()
	attr_lineinterpolation := m.LineInterpolation.ValueStringPointer()
	var attr_linestyle interface{}
	if m.LineStyle != nil {
		attr_linestyle = m.LineStyle
	}
	attr_fillcolor := m.FillColor.ValueStringPointer()
	attr_fillopacity := m.FillOpacity.ValueFloat64Pointer()
	attr_showpoints := m.ShowPoints.ValueStringPointer()
	attr_pointsize := m.PointSize.ValueFloat64Pointer()
	attr_pointcolor := m.PointColor.ValueStringPointer()
	attr_axisplacement := m.AxisPlacement.ValueStringPointer()
	attr_axiscolormode := m.AxisColorMode.ValueStringPointer()
	attr_axislabel := m.AxisLabel.ValueStringPointer()
	attr_axiswidth := m.AxisWidth.ValueFloat64Pointer()
	attr_axissoftmin := m.AxisSoftMin.ValueFloat64Pointer()
	attr_axissoftmax := m.AxisSoftMax.ValueFloat64Pointer()
	attr_axisgridshow := m.AxisGridShow.ValueBoolPointer()
	var attr_scaledistribution interface{}
	if m.ScaleDistribution != nil {
		attr_scaledistribution = m.ScaleDistribution
	}
	attr_baralignment := m.BarAlignment.ValueInt64Pointer()
	attr_barwidthfactor := m.BarWidthFactor.ValueFloat64Pointer()
	var attr_stacking interface{}
	if m.Stacking != nil {
		attr_stacking = m.Stacking
	}
	var attr_hidefrom interface{}
	if m.HideFrom != nil {
		attr_hidefrom = m.HideFrom
	}
	attr_transform := m.Transform.ValueStringPointer()
	attr_spannulls := m.GetAttrSpanNulls()
	attr_fillbelowto := m.FillBelowTo.ValueStringPointer()
	attr_pointsymbol := m.PointSymbol.ValueStringPointer()
	attr_axiscenteredzero := m.AxisCenteredZero.ValueBoolPointer()
	attr_barmaxwidth := m.BarMaxWidth.ValueFloat64Pointer()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults_Custom{
		DrawStyle:         attr_drawstyle,
		GradientMode:      attr_gradientmode,
		ThresholdsStyle:   attr_thresholdsstyle,
		LineColor:         attr_linecolor,
		LineWidth:         attr_linewidth,
		LineInterpolation: attr_lineinterpolation,
		LineStyle:         attr_linestyle,
		FillColor:         attr_fillcolor,
		FillOpacity:       attr_fillopacity,
		ShowPoints:        attr_showpoints,
		PointSize:         attr_pointsize,
		PointColor:        attr_pointcolor,
		AxisPlacement:     attr_axisplacement,
		AxisColorMode:     attr_axiscolormode,
		AxisLabel:         attr_axislabel,
		AxisWidth:         attr_axiswidth,
		AxisSoftMin:       attr_axissoftmin,
		AxisSoftMax:       attr_axissoftmax,
		AxisGridShow:      attr_axisgridshow,
		ScaleDistribution: attr_scaledistribution,
		BarAlignment:      attr_baralignment,
		BarWidthFactor:    attr_barwidthfactor,
		Stacking:          attr_stacking,
		HideFrom:          attr_hidefrom,
		Transform:         attr_transform,
		SpanNulls:         attr_spannulls,
		FillBelowTo:       attr_fillbelowto,
		PointSymbol:       attr_pointsymbol,
		AxisCenteredZero:  attr_axiscenteredzero,
		BarMaxWidth:       attr_barmaxwidth,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Defaults struct {
	DisplayName       types.String                                                `tfsdk:"display_name"`
	DisplayNameFromDS types.String                                                `tfsdk:"display_name_from_ds"`
	Description       types.String                                                `tfsdk:"description"`
	Path              types.String                                                `tfsdk:"path"`
	Writeable         types.Bool                                                  `tfsdk:"writeable"`
	Filterable        types.Bool                                                  `tfsdk:"filterable"`
	Unit              types.String                                                `tfsdk:"unit"`
	Decimals          types.Float64                                               `tfsdk:"decimals"`
	Min               types.Float64                                               `tfsdk:"min"`
	Max               types.Float64                                               `tfsdk:"max"`
	Mappings          []PanelCanvasDataSourceModel_FieldConfig_Defaults_Mappings  `tfsdk:"mappings"`
	Thresholds        *PanelCanvasDataSourceModel_FieldConfig_Defaults_Thresholds `tfsdk:"thresholds"`
	Color             *PanelCanvasDataSourceModel_FieldConfig_Defaults_Color      `tfsdk:"color"`
	NoValue           types.String                                                `tfsdk:"no_value"`
	Custom            *PanelCanvasDataSourceModel_FieldConfig_Defaults_Custom     `tfsdk:"custom"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Defaults struct {
		DisplayName       *string       `json:"displayName,omitempty"`
		DisplayNameFromDS *string       `json:"displayNameFromDS,omitempty"`
		Description       *string       `json:"description,omitempty"`
		Path              *string       `json:"path,omitempty"`
		Writeable         *bool         `json:"writeable,omitempty"`
		Filterable        *bool         `json:"filterable,omitempty"`
		Unit              *string       `json:"unit,omitempty"`
		Decimals          *float64      `json:"decimals,omitempty"`
		Min               *float64      `json:"min,omitempty"`
		Max               *float64      `json:"max,omitempty"`
		Mappings          []interface{} `json:"mappings,omitempty"`
		Thresholds        interface{}   `json:"thresholds,omitempty"`
		Color             interface{}   `json:"color,omitempty"`
		NoValue           *string       `json:"noValue,omitempty"`
		Custom            interface{}   `json:"custom,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_displayname := m.DisplayName.ValueStringPointer()
	attr_displaynamefromds := m.DisplayNameFromDS.ValueStringPointer()
	attr_description := m.Description.ValueStringPointer()
	attr_path := m.Path.ValueStringPointer()
	attr_writeable := m.Writeable.ValueBoolPointer()
	attr_filterable := m.Filterable.ValueBoolPointer()
	attr_unit := m.Unit.ValueStringPointer()
	attr_decimals := m.Decimals.ValueFloat64Pointer()
	attr_min := m.Min.ValueFloat64Pointer()
	attr_max := m.Max.ValueFloat64Pointer()
	attr_mappings := []interface{}{}
	for _, v := range m.Mappings {
		attr_mappings = append(attr_mappings, v)
	}
	var attr_thresholds interface{}
	if m.Thresholds != nil {
		attr_thresholds = m.Thresholds
	}
	var attr_color interface{}
	if m.Color != nil {
		attr_color = m.Color
	}
	attr_novalue := m.NoValue.ValueStringPointer()
	var attr_custom interface{}
	if m.Custom != nil {
		attr_custom = m.Custom
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Defaults{
		DisplayName:       attr_displayname,
		DisplayNameFromDS: attr_displaynamefromds,
		Description:       attr_description,
		Path:              attr_path,
		Writeable:         attr_writeable,
		Filterable:        attr_filterable,
		Unit:              attr_unit,
		Decimals:          attr_decimals,
		Min:               attr_min,
		Max:               attr_max,
		Mappings:          attr_mappings,
		Thresholds:        attr_thresholds,
		Color:             attr_color,
		NoValue:           attr_novalue,
		Custom:            attr_custom,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Defaults) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Defaults {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher struct {
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher{}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Overrides_Properties struct {
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides_Properties) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Overrides_Properties struct {
	}

	m = m.ApplyDefaults()

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Overrides_Properties{}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides_Properties) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Overrides_Properties {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig_Overrides struct {
	Matcher    *PanelCanvasDataSourceModel_FieldConfig_Overrides_Matcher     `tfsdk:"matcher"`
	Properties []PanelCanvasDataSourceModel_FieldConfig_Overrides_Properties `tfsdk:"properties"`
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig_Overrides struct {
		Matcher    interface{}   `json:"matcher,omitempty"`
		Properties []interface{} `json:"properties,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_matcher interface{}
	if m.Matcher != nil {
		attr_matcher = m.Matcher
	}
	attr_properties := []interface{}{}
	for _, v := range m.Properties {
		attr_properties = append(attr_properties, v)
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig_Overrides{
		Matcher:    attr_matcher,
		Properties: attr_properties,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig_Overrides) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig_Overrides {

	return m
}

type PanelCanvasDataSourceModel_FieldConfig struct {
	Defaults  *PanelCanvasDataSourceModel_FieldConfig_Defaults   `tfsdk:"defaults"`
	Overrides []PanelCanvasDataSourceModel_FieldConfig_Overrides `tfsdk:"overrides"`
}

func (m PanelCanvasDataSourceModel_FieldConfig) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel_FieldConfig struct {
		Defaults  interface{}   `json:"defaults,omitempty"`
		Overrides []interface{} `json:"overrides,omitempty"`
	}

	m = m.ApplyDefaults()
	var attr_defaults interface{}
	if m.Defaults != nil {
		attr_defaults = m.Defaults
	}
	attr_overrides := []interface{}{}
	for _, v := range m.Overrides {
		attr_overrides = append(attr_overrides, v)
	}

	model := &jsonPanelCanvasDataSourceModel_FieldConfig{
		Defaults:  attr_defaults,
		Overrides: attr_overrides,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel_FieldConfig) ApplyDefaults() PanelCanvasDataSourceModel_FieldConfig {

	return m
}

type PanelCanvasDataSourceModel struct {
	RenderedJSON    types.String                                 `tfsdk:"rendered_json"`
	Type            types.String                                 `tfsdk:"type"`
	PluginVersion   types.String                                 `tfsdk:"plugin_version"`
	Tags            types.List                                   `tfsdk:"tags"`
	Targets         types.List                                   `tfsdk:"targets"`
	Title           types.String                                 `tfsdk:"title"`
	Description     types.String                                 `tfsdk:"description"`
	Transparent     types.Bool                                   `tfsdk:"transparent"`
	Datasource      *PanelCanvasDataSourceModel_Datasource       `tfsdk:"datasource"`
	GridPos         *PanelCanvasDataSourceModel_GridPos          `tfsdk:"grid_pos"`
	Links           []PanelCanvasDataSourceModel_Links           `tfsdk:"links"`
	Repeat          types.String                                 `tfsdk:"repeat"`
	RepeatDirection types.String                                 `tfsdk:"repeat_direction"`
	RepeatPanelId   types.Int64                                  `tfsdk:"repeat_panel_id"`
	MaxDataPoints   types.Float64                                `tfsdk:"max_data_points"`
	Transformations []PanelCanvasDataSourceModel_Transformations `tfsdk:"transformations"`
	Interval        types.String                                 `tfsdk:"interval"`
	TimeFrom        types.String                                 `tfsdk:"time_from"`
	TimeShift       types.String                                 `tfsdk:"time_shift"`
	LibraryPanel    *PanelCanvasDataSourceModel_LibraryPanel     `tfsdk:"library_panel"`
	Options         *PanelCanvasDataSourceModel_Options          `tfsdk:"options"`
	FieldConfig     *PanelCanvasDataSourceModel_FieldConfig      `tfsdk:"field_config"`
}

func (m PanelCanvasDataSourceModel) MarshalJSON() ([]byte, error) {
	type jsonPanelCanvasDataSourceModel struct {
		Type            string        `json:"type"`
		PluginVersion   *string       `json:"pluginVersion,omitempty"`
		Tags            []string      `json:"tags,omitempty"`
		Targets         []string      `json:"targets,omitempty"`
		Title           *string       `json:"title,omitempty"`
		Description     *string       `json:"description,omitempty"`
		Transparent     bool          `json:"transparent"`
		Datasource      interface{}   `json:"datasource,omitempty"`
		GridPos         interface{}   `json:"gridPos,omitempty"`
		Links           []interface{} `json:"links,omitempty"`
		Repeat          *string       `json:"repeat,omitempty"`
		RepeatDirection *string       `json:"repeatDirection,omitempty"`
		RepeatPanelId   *int64        `json:"repeatPanelId,omitempty"`
		MaxDataPoints   *float64      `json:"maxDataPoints,omitempty"`
		Transformations []interface{} `json:"transformations,omitempty"`
		Interval        *string       `json:"interval,omitempty"`
		TimeFrom        *string       `json:"timeFrom,omitempty"`
		TimeShift       *string       `json:"timeShift,omitempty"`
		LibraryPanel    interface{}   `json:"libraryPanel,omitempty"`
		Options         interface{}   `json:"options,omitempty"`
		FieldConfig     interface{}   `json:"fieldConfig,omitempty"`
	}

	m = m.ApplyDefaults()
	attr_type := m.Type.ValueString()
	attr_pluginversion := m.PluginVersion.ValueStringPointer()
	attr_tags := []string{}
	for _, v := range m.Tags.Elements() {
		attr_tags = append(attr_tags, v.(types.String).ValueString())
	}
	attr_targets := []string{}
	for _, v := range m.Targets.Elements() {
		attr_targets = append(attr_targets, v.(types.String).ValueString())
	}
	attr_title := m.Title.ValueStringPointer()
	attr_description := m.Description.ValueStringPointer()
	attr_transparent := m.Transparent.ValueBool()
	var attr_datasource interface{}
	if m.Datasource != nil {
		attr_datasource = m.Datasource
	}
	var attr_gridpos interface{}
	if m.GridPos != nil {
		attr_gridpos = m.GridPos
	}
	attr_links := []interface{}{}
	for _, v := range m.Links {
		attr_links = append(attr_links, v)
	}
	attr_repeat := m.Repeat.ValueStringPointer()
	attr_repeatdirection := m.RepeatDirection.ValueStringPointer()
	attr_repeatpanelid := m.RepeatPanelId.ValueInt64Pointer()
	attr_maxdatapoints := m.MaxDataPoints.ValueFloat64Pointer()
	attr_transformations := []interface{}{}
	for _, v := range m.Transformations {
		attr_transformations = append(attr_transformations, v)
	}
	attr_interval := m.Interval.ValueStringPointer()
	attr_timefrom := m.TimeFrom.ValueStringPointer()
	attr_timeshift := m.TimeShift.ValueStringPointer()
	var attr_librarypanel interface{}
	if m.LibraryPanel != nil {
		attr_librarypanel = m.LibraryPanel
	}
	var attr_options interface{}
	if m.Options != nil {
		attr_options = m.Options
	}
	var attr_fieldconfig interface{}
	if m.FieldConfig != nil {
		attr_fieldconfig = m.FieldConfig
	}

	model := &jsonPanelCanvasDataSourceModel{
		Type:            attr_type,
		PluginVersion:   attr_pluginversion,
		Tags:            attr_tags,
		Targets:         attr_targets,
		Title:           attr_title,
		Description:     attr_description,
		Transparent:     attr_transparent,
		Datasource:      attr_datasource,
		GridPos:         attr_gridpos,
		Links:           attr_links,
		Repeat:          attr_repeat,
		RepeatDirection: attr_repeatdirection,
		RepeatPanelId:   attr_repeatpanelid,
		MaxDataPoints:   attr_maxdatapoints,
		Transformations: attr_transformations,
		Interval:        attr_interval,
		TimeFrom:        attr_timefrom,
		TimeShift:       attr_timeshift,
		LibraryPanel:    attr_librarypanel,
		Options:         attr_options,
		FieldConfig:     attr_fieldconfig,
	}
	return json.Marshal(model)
}

func (m PanelCanvasDataSourceModel) ApplyDefaults() PanelCanvasDataSourceModel {
	if m.Type.IsNull() {
		m.Type = types.StringValue(`canvas`)
	}
	if len(m.Tags.Elements()) == 0 {
		m.Tags, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if len(m.Targets.Elements()) == 0 {
		m.Targets, _ = types.ListValue(types.StringType, []attr.Value{})
	}
	if m.Transparent.IsNull() {
		m.Transparent = types.BoolValue(false)
	}
	if m.RepeatDirection.IsNull() {
		m.RepeatDirection = types.StringValue(`h`)
	}
	return m
}

func (d *PanelCanvasDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_panel_canvas"
}

func (d *PanelCanvasDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "",
		Attributes: map[string]schema.Attribute{
			"type": schema.StringAttribute{
				MarkdownDescription: `The panel plugin type id. This is used to find the plugin to display the panel. Defaults to "canvas".`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"plugin_version": schema.StringAttribute{
				MarkdownDescription: `The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: `Tags for the panel.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"targets": schema.ListAttribute{
				MarkdownDescription: `Depends on the panel plugin. See the plugin documentation for details.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				ElementType:         types.StringType,
			},
			"title": schema.StringAttribute{
				MarkdownDescription: `Panel title.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: `Panel description.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transparent": schema.BoolAttribute{
				MarkdownDescription: `Whether to display the panel without a background. Defaults to false.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
			},
			"datasource": schema.SingleNestedAttribute{
				MarkdownDescription: `The datasource used in all targets.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"type": schema.StringAttribute{
						MarkdownDescription: `The plugin type-id`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: `Specific datasource instance`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"grid_pos": schema.SingleNestedAttribute{
				MarkdownDescription: `Grid position.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"h": schema.Int64Attribute{
						MarkdownDescription: `Panel height. The height is the number of rows from the top edge of the panel. Defaults to 9.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"w": schema.Int64Attribute{
						MarkdownDescription: `Panel width. The width is the number of columns from the left edge of the panel. Defaults to 12.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"x": schema.Int64Attribute{
						MarkdownDescription: `Panel x. The x coordinate is the number of columns from the left edge of the grid. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"y": schema.Int64Attribute{
						MarkdownDescription: `Panel y. The y coordinate is the number of rows from the top edge of the grid. Defaults to 0.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"static": schema.BoolAttribute{
						MarkdownDescription: `Whether the panel is fixed within the grid. If true, the panel will not be affected by other panels' interactions`,
						Computed:            false,
						Optional:            true,
						Required:            false,
					},
				},
			},
			"links": schema.ListNestedAttribute{
				MarkdownDescription: `Panel links.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"title": schema.StringAttribute{
							MarkdownDescription: `Title to display with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"type": schema.StringAttribute{
							MarkdownDescription: `Link type. Accepted values are dashboards (to refer to another dashboard) and link (to refer to an external resource)`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"icon": schema.StringAttribute{
							MarkdownDescription: `Icon name to be displayed with the link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tooltip": schema.StringAttribute{
							MarkdownDescription: `Tooltip to display when the user hovers their mouse over it`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"url": schema.StringAttribute{
							MarkdownDescription: `Link URL. Only required/valid if the type is link`,
							Computed:            false,
							Optional:            false,
							Required:            true,
						},
						"tags": schema.ListAttribute{
							MarkdownDescription: `List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards`,
							Computed:            false,
							Optional:            true,
							Required:            false,
							ElementType:         types.StringType,
						},
						"as_dropdown": schema.BoolAttribute{
							MarkdownDescription: `If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"target_blank": schema.BoolAttribute{
							MarkdownDescription: `If true, the link will be opened in a new tab. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"include_vars": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current template variables values in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
						"keep_time": schema.BoolAttribute{
							MarkdownDescription: `If true, includes current time range in the link as query params. Defaults to false.`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"repeat": schema.StringAttribute{
				MarkdownDescription: `Name of template variable to repeat for.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"repeat_direction": schema.StringAttribute{
				MarkdownDescription: `Direction to repeat in if 'repeat' is set.
h for horizontal, v for vertical. Defaults to "h".`,
				Computed: true,
				Optional: true,
				Required: false,
			},
			"repeat_panel_id": schema.Int64Attribute{
				MarkdownDescription: `Id of the repeating panel.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"max_data_points": schema.Float64Attribute{
				MarkdownDescription: `The maximum number of data points that the panel queries are retrieving.`,
				Computed:            false,
				Optional:            true,
				Required:            false,
			},
			"transformations": schema.ListNestedAttribute{
				MarkdownDescription: `List of transformations that are applied to the panel data before rendering.
When there are multiple transformations, Grafana applies them in the order they are listed.
Each transformation creates a result set that then passes on to the next transformation in the processing pipeline.`,
				Computed: false,
				Optional: true,
				Required: false,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"disabled": schema.BoolAttribute{
							MarkdownDescription: `Disabled transformations are skipped`,
							Computed:            false,
							Optional:            true,
							Required:            false,
						},
						"filter": schema.SingleNestedAttribute{
							MarkdownDescription: `Optional frame matcher. When missing it will be applied to all results`,
							Computed:            true,
							Optional:            true,
							Required:            false,
						},
					},
				},
			},
			"interval": schema.StringAttribute{
				MarkdownDescription: `The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.
This value must be formatted as a number followed by a valid time
identifier like: "40s", "3d", etc.
See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_from": schema.StringAttribute{
				MarkdownDescription: `Overrides the relative time range for individual panels,
which causes them to be different than what is selected in
the dashboard time picker in the top-right corner of the dashboard. You can use this to show metrics from different
time periods or days on the same dashboard.
The value is formatted as time operation like: now-5m (Last 5 minutes), now/d (the day so far),
now-5d/d(Last 5 days), now/w (This week so far), now-2y/y (Last 2 years).
Note: Panel time overrides have no effect when the dashboards time range is absolute.
See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"time_shift": schema.StringAttribute{
				MarkdownDescription: `Overrides the time range for individual panels by shifting its start and end relative to the time picker.
For example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting 2h.
Note: Panel time overrides have no effect when the dashboards time range is absolute.
See: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options`,
				Computed: false,
				Optional: true,
				Required: false,
			},
			"library_panel": schema.SingleNestedAttribute{
				MarkdownDescription: `Dynamically load the panel`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: `Library panel name`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
					"uid": schema.StringAttribute{
						MarkdownDescription: `Library panel uid`,
						Computed:            false,
						Optional:            false,
						Required:            true,
					},
				},
			},
			"options": schema.SingleNestedAttribute{
				MarkdownDescription: ``,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"inline_editing": schema.BoolAttribute{
						MarkdownDescription: `Enable inline editing. Defaults to true.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"show_advanced_types": schema.BoolAttribute{
						MarkdownDescription: `Show all available element types. Defaults to true.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
					},
					"root": schema.SingleNestedAttribute{
						MarkdownDescription: `The root element of canvas (frame), where all canvas elements are nested
TODO: Figure out how to define a default value for this`,
						Computed: true,
						Optional: true,
						Required: false,
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: `Name of the root element`,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"type": schema.StringAttribute{
								MarkdownDescription: `Type of root element (frame)`,
								Computed:            false,
								Optional:            false,
								Required:            true,
							},
							"elements": schema.ListNestedAttribute{
								MarkdownDescription: `The list of canvas elements attached to the root element`,
								Computed:            false,
								Optional:            true,
								Required:            false,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            false,
											Required:            true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            false,
											Required:            true,
										},
										"constraint": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"horizontal": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"vertical": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
											},
										},
										"placement": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"top": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"left": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"right": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"bottom": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"width": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
												"height": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
											},
										},
										"background": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"color": schema.SingleNestedAttribute{
													MarkdownDescription: ``,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"fixed": schema.StringAttribute{
															MarkdownDescription: ``,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
														"field": schema.StringAttribute{
															MarkdownDescription: `fixed: T -- will be added by each element`,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
													},
												},
												"image": schema.SingleNestedAttribute{
													MarkdownDescription: ``,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: ``,
															Computed:            false,
															Optional:            false,
															Required:            true,
														},
														"field": schema.StringAttribute{
															MarkdownDescription: `fixed: T -- will be added by each element`,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
														"fixed": schema.StringAttribute{
															MarkdownDescription: ``,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
													},
												},
												"size": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
											},
										},
										"border": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"color": schema.SingleNestedAttribute{
													MarkdownDescription: ``,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"fixed": schema.StringAttribute{
															MarkdownDescription: ``,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
														"field": schema.StringAttribute{
															MarkdownDescription: `fixed: T -- will be added by each element`,
															Computed:            false,
															Optional:            true,
															Required:            false,
														},
													},
												},
												"width": schema.Float64Attribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            true,
													Required:            false,
												},
											},
										},
										"connections": schema.ListNestedAttribute{
											MarkdownDescription: ``,
											Computed:            false,
											Optional:            true,
											Required:            false,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"source": schema.SingleNestedAttribute{
														MarkdownDescription: ``,
														Computed:            true,
														Optional:            true,
														Required:            false,
														Attributes: map[string]schema.Attribute{
															"x": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
															"y": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
														},
													},
													"target": schema.SingleNestedAttribute{
														MarkdownDescription: ``,
														Computed:            true,
														Optional:            true,
														Required:            false,
														Attributes: map[string]schema.Attribute{
															"x": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
															"y": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
														},
													},
													"target_name": schema.StringAttribute{
														MarkdownDescription: ``,
														Computed:            false,
														Optional:            true,
														Required:            false,
													},
													"path": schema.StringAttribute{
														MarkdownDescription: ``,
														Computed:            false,
														Optional:            false,
														Required:            true,
													},
													"color": schema.SingleNestedAttribute{
														MarkdownDescription: ``,
														Computed:            true,
														Optional:            true,
														Required:            false,
														Attributes: map[string]schema.Attribute{
															"fixed": schema.StringAttribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"field": schema.StringAttribute{
																MarkdownDescription: `fixed: T -- will be added by each element`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
														},
													},
													"size": schema.SingleNestedAttribute{
														MarkdownDescription: ``,
														Computed:            true,
														Optional:            true,
														Required:            false,
														Attributes: map[string]schema.Attribute{
															"min": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
															"max": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            false,
																Required:            true,
															},
															"fixed": schema.Float64Attribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"field": schema.StringAttribute{
																MarkdownDescription: `fixed: T -- will be added by each element`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"mode": schema.StringAttribute{
																MarkdownDescription: ``,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"field_config": schema.SingleNestedAttribute{
				MarkdownDescription: `Field options allow you to change how the data is displayed in your visualizations.`,
				Computed:            true,
				Optional:            true,
				Required:            false,
				Attributes: map[string]schema.Attribute{
					"defaults": schema.SingleNestedAttribute{
						MarkdownDescription: `Defaults are the options applied to all fields.`,
						Computed:            true,
						Optional:            true,
						Required:            false,
						Attributes: map[string]schema.Attribute{
							"display_name": schema.StringAttribute{
								MarkdownDescription: `The display value for this field.  This supports template variables blank is auto`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"display_name_from_ds": schema.StringAttribute{
								MarkdownDescription: `This can be used by data sources that return and explicit naming structure for values and labels
When this property is configured, this value is used rather than the default naming strategy.`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"description": schema.StringAttribute{
								MarkdownDescription: `Human readable field metadata`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"path": schema.StringAttribute{
								MarkdownDescription: `An explicit path to the field in the datasource.  When the frame meta includes a path,
This will default to ${frame.meta.path}/${field.name}

When defined, this value can be used as an identifier within the datasource scope, and
may be used to update the results`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"writeable": schema.BoolAttribute{
								MarkdownDescription: `True if data source can write a value to the path. Auth/authz are supported separately`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"filterable": schema.BoolAttribute{
								MarkdownDescription: `True if data source field supports ad-hoc filters`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"unit": schema.StringAttribute{
								MarkdownDescription: `Unit a field should use. The unit you select is applied to all fields except time.
You can use the units ID availables in Grafana or a custom unit.
Available units in Grafana: https://github.com/grafana/grafana/blob/main/packages/grafana-data/src/valueFormats/categories.ts
As custom unit, you can use the following formats:
suffix:<suffix> for custom unit that should go after value.
prefix:<prefix> for custom unit that should go before value.
time:<format> For custom date time formats type for example time:YYYY-MM-DD.
si:<base scale><unit characters> for custom SI units. For example: si: mF. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.
count:<unit> for a custom count unit.
currency:<unit> for custom a currency unit.`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"decimals": schema.Float64Attribute{
								MarkdownDescription: `Specify the number of decimals Grafana includes in the rendered value.
If you leave this field blank, Grafana automatically truncates the number of decimals based on the value.
For example 1.1234 will display as 1.12 and 100.456 will display as 100.
To display all decimals, set the unit to String.`,
								Computed: false,
								Optional: true,
								Required: false,
							},
							"min": schema.Float64Attribute{
								MarkdownDescription: `The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"max": schema.Float64Attribute{
								MarkdownDescription: `The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"mappings": schema.ListNestedAttribute{
								MarkdownDescription: `Convert input values into a display string`,
								Computed:            false,
								Optional:            true,
								Required:            false,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"value_map": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"options": schema.MapNestedAttribute{
													MarkdownDescription: `Map with <value_to_match>: ValueMappingResult. For example: { "10": { text: "Perfection!", color: "green" } }`,
													Computed:            false,
													Optional:            true,
													Required:            false,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"text": schema.StringAttribute{
																MarkdownDescription: `Text to display when the value matches`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"color": schema.StringAttribute{
																MarkdownDescription: `Text to use when the value matches`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"icon": schema.StringAttribute{
																MarkdownDescription: `Icon to display when the value matches. Only specific visualizations.`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
															"index": schema.Int64Attribute{
																MarkdownDescription: `Position in the mapping array. Only used internally.`,
																Computed:            false,
																Optional:            true,
																Required:            false,
															},
														},
													},
												},
											},
										},
										"range_map": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"options": schema.SingleNestedAttribute{
													MarkdownDescription: `Range to match against and the result to apply when the value is within the range`,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"from": schema.StringAttribute{
															MarkdownDescription: `Min value of the range. It can be null which means -Infinity`,
															Computed:            false,
															Optional:            false,
															Required:            true,
														},
														"to": schema.StringAttribute{
															MarkdownDescription: `Max value of the range. It can be null which means +Infinity`,
															Computed:            false,
															Optional:            false,
															Required:            true,
														},
														"result": schema.SingleNestedAttribute{
															MarkdownDescription: `Config to apply when the value is within the range`,
															Computed:            true,
															Optional:            true,
															Required:            false,
															Attributes: map[string]schema.Attribute{
																"text": schema.StringAttribute{
																	MarkdownDescription: `Text to display when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"color": schema.StringAttribute{
																	MarkdownDescription: `Text to use when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"icon": schema.StringAttribute{
																	MarkdownDescription: `Icon to display when the value matches. Only specific visualizations.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"index": schema.Int64Attribute{
																	MarkdownDescription: `Position in the mapping array. Only used internally.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
															},
														},
													},
												},
											},
										},
										"regex_map": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"options": schema.SingleNestedAttribute{
													MarkdownDescription: `Regular expression to match against and the result to apply when the value matches the regex`,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"pattern": schema.StringAttribute{
															MarkdownDescription: `Regular expression to match against`,
															Computed:            false,
															Optional:            false,
															Required:            true,
														},
														"result": schema.SingleNestedAttribute{
															MarkdownDescription: `Config to apply when the value matches the regex`,
															Computed:            true,
															Optional:            true,
															Required:            false,
															Attributes: map[string]schema.Attribute{
																"text": schema.StringAttribute{
																	MarkdownDescription: `Text to display when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"color": schema.StringAttribute{
																	MarkdownDescription: `Text to use when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"icon": schema.StringAttribute{
																	MarkdownDescription: `Icon to display when the value matches. Only specific visualizations.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"index": schema.Int64Attribute{
																	MarkdownDescription: `Position in the mapping array. Only used internally.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
															},
														},
													},
												},
											},
										},
										"special_value_map": schema.SingleNestedAttribute{
											MarkdownDescription: ``,
											Computed:            true,
											Optional:            true,
											Required:            false,
											Attributes: map[string]schema.Attribute{
												"type": schema.StringAttribute{
													MarkdownDescription: ``,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
												"options": schema.SingleNestedAttribute{
													MarkdownDescription: ``,
													Computed:            true,
													Optional:            true,
													Required:            false,
													Attributes: map[string]schema.Attribute{
														"match": schema.StringAttribute{
															MarkdownDescription: `Special value to match against`,
															Computed:            false,
															Optional:            false,
															Required:            true,
														},
														"result": schema.SingleNestedAttribute{
															MarkdownDescription: `Config to apply when the value matches the special value`,
															Computed:            true,
															Optional:            true,
															Required:            false,
															Attributes: map[string]schema.Attribute{
																"text": schema.StringAttribute{
																	MarkdownDescription: `Text to display when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"color": schema.StringAttribute{
																	MarkdownDescription: `Text to use when the value matches`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"icon": schema.StringAttribute{
																	MarkdownDescription: `Icon to display when the value matches. Only specific visualizations.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
																"index": schema.Int64Attribute{
																	MarkdownDescription: `Position in the mapping array. Only used internally.`,
																	Computed:            false,
																	Optional:            true,
																	Required:            false,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"thresholds": schema.SingleNestedAttribute{
								MarkdownDescription: `Map numeric values to states`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `Thresholds mode.`,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"steps": schema.ListNestedAttribute{
										MarkdownDescription: `Must be sorted by 'value', first value is always -Infinity`,
										Computed:            false,
										Optional:            true,
										Required:            false,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"value": schema.StringAttribute{
													MarkdownDescription: `Value represents a specified metric for the threshold, which triggers a visual change in the dashboard when this value is met or exceeded.
Nulls currently appear here when serializing -Infinity to JSON.`,
													Computed: false,
													Optional: false,
													Required: true,
												},
												"color": schema.StringAttribute{
													MarkdownDescription: `Color represents the color of the visual change that will occur in the dashboard when the threshold value is met or exceeded.`,
													Computed:            false,
													Optional:            false,
													Required:            true,
												},
											},
										},
									},
								},
							},
							"color": schema.SingleNestedAttribute{
								MarkdownDescription: `Panel color configuration`,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"mode": schema.StringAttribute{
										MarkdownDescription: `The main color scheme mode.`,
										Computed:            false,
										Optional:            false,
										Required:            true,
									},
									"fixed_color": schema.StringAttribute{
										MarkdownDescription: `The fixed color value for fixed or shades color modes.`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"series_by": schema.StringAttribute{
										MarkdownDescription: `Some visualizations need to know how to assign a series color from by value color schemes.`,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
							"no_value": schema.StringAttribute{
								MarkdownDescription: `Alternative to empty string`,
								Computed:            false,
								Optional:            true,
								Required:            false,
							},
							"custom": schema.SingleNestedAttribute{
								MarkdownDescription: ``,
								Computed:            true,
								Optional:            true,
								Required:            false,
								Attributes: map[string]schema.Attribute{
									"draw_style": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"gradient_mode": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"thresholds_style": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
										},
									},
									"line_color": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"line_width": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"line_interpolation": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"line_style": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"fill": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"dash": schema.ListAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
												ElementType:         types.Float64Type,
											},
										},
									},
									"fill_color": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"fill_opacity": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"show_points": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"point_size": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"point_color": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_placement": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_color_mode": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_label": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_width": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_soft_min": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_soft_max": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_grid_show": schema.BoolAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"scale_distribution": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"type": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"log": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"linear_threshold": schema.Float64Attribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
										},
									},
									"bar_alignment": schema.Int64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"bar_width_factor": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"stacking": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
											"group": schema.StringAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            true,
												Required:            false,
											},
										},
									},
									"hide_from": schema.SingleNestedAttribute{
										MarkdownDescription: ``,
										Computed:            true,
										Optional:            true,
										Required:            false,
										Attributes: map[string]schema.Attribute{
											"tooltip": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"legend": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
											"viz": schema.BoolAttribute{
												MarkdownDescription: ``,
												Computed:            false,
												Optional:            false,
												Required:            true,
											},
										},
									},
									"transform": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"span_nulls": schema.StringAttribute{
										MarkdownDescription: `Indicate if null values should be treated as gaps or connected.
When the value is a number, it represents the maximum delta in the
X axis that should be considered connected.  For timeseries, this is milliseconds`,
										Computed: false,
										Optional: true,
										Required: false,
									},
									"fill_below_to": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"point_symbol": schema.StringAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"axis_centered_zero": schema.BoolAttribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
									"bar_max_width": schema.Float64Attribute{
										MarkdownDescription: ``,
										Computed:            false,
										Optional:            true,
										Required:            false,
									},
								},
							},
						},
					},
					"overrides": schema.ListNestedAttribute{
						MarkdownDescription: `Overrides are the options applied to specific fields overriding the defaults.`,
						Computed:            false,
						Optional:            true,
						Required:            false,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"matcher": schema.SingleNestedAttribute{
									MarkdownDescription: ``,
									Computed:            true,
									Optional:            true,
									Required:            false,
								},
								"properties": schema.ListNestedAttribute{
									MarkdownDescription: ``,
									Computed:            false,
									Optional:            true,
									Required:            false,
								},
							},
						},
					},
				},
			},

			"rendered_json": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "This datasource rendered as JSON",
			},
		},
	}
}

func (d *PanelCanvasDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
}

func (d *PanelCanvasDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data PanelCanvasDataSourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	JSONConfig, err := json.Marshal(data)
	if err != nil {
		resp.Diagnostics.AddError("JSON marshalling error", err.Error())
		return
	}

	// fix up the targets Attribute
	// Read into a map[string]interface{} and then marshal it back to JSON
	// This is a workaround for the fact that the targets attribute should be a list of maps but is a list of json strings
	dataMap := make(map[string]interface{})
	err = json.Unmarshal(JSONConfig, &dataMap)
	if err != nil {
		resp.Diagnostics.AddError("error unmarshalling config into Go map", err.Error())
		return
	}
	targets := data.Targets.Elements()
	targetsMaps := make([]map[string]interface{}, len(targets))
	for i, target := range targets {
		targetMap := make(map[string]interface{})
		err = json.Unmarshal([]byte(target.(types.String).ValueString()), &targetMap)
		if err != nil {
			resp.Diagnostics.AddError("error unmarshalling target into go map", err.Error())
			return
		}
		targetsMaps[i] = targetMap
	}

	dataMap["targets"] = targetsMaps
	JSONConfig, err = json.MarshalIndent(dataMap, "", "  ")
	if err != nil {
		resp.Diagnostics.AddError("error marshalling go map into json", err.Error())
		return
	}

	// Not sure about that
	data.RenderedJSON = types.StringValue(string(JSONConfig))

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read a data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
